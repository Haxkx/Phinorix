<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Trading Bot - Deep Market Analysis</title>
    
    <!-- TradingView Widget -->
    <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c, #1a1a2e);
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
            gap: 0;
        }
        
        .sidebar {
            width: 350px;
            min-width: 350px;
            background: rgba(20, 20, 30, 0.98);
            padding: 20px;
            border-right: 1px solid #333;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0c0c0c;
            min-width: 0;
        }
        
        .chart-container {
            flex: 1;
            position: relative;
            min-height: 0;
        }
        
        #tradingview_chart {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        .control-panel {
            background: rgba(30, 30, 45, 0.95);
            padding: 15px 20px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .start-stop-btn {
            background: linear-gradient(135deg, #00d4aa, #009975);
            border: none;
            color: #000;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 140px;
        }
        
        .start-stop-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 212, 170, 0.4);
        }
        
        .start-stop-btn.stop {
            background: linear-gradient(135deg, #ff6b35, #cc552a);
        }
        
        .start-stop-btn.stop:hover {
            box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
        }
        
        .symbol-selector {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .symbol-select {
            background: #2a2a3a;
            border: 1px solid #444;
            color: #fff;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 14px;
            min-width: 140px;
            cursor: pointer;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 15px 0;
        }
        
        .stat-card {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .stat-value {
            font-size: 16px;
            font-weight: bold;
            margin-top: 8px;
        }
        
        .positive { color: #00d4aa; }
        .negative { color: #ff6b35; }
        .neutral { color: #cccccc; }
        .hold { color: #ffeb3b; }
        
        .signal-section {
            background: #2a2a3a;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
            border: 1px solid #444;
            min-height: 140px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .signal-buy {
            color: #00d4aa;
            font-weight: bold;
            font-size: 18px;
        }
        
        .signal-sell {
            color: #ff6b35;
            font-weight: bold;
            font-size: 18px;
        }
        
        .signal-hold {
            color: #ffeb3b;
            font-weight: bold;
            font-size: 18px;
        }
        
        .prediction-section {
            background: #2a2a3a;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border: 1px solid #444;
        }
        
        .prediction-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px 0;
        }
        
        .analysis-section {
            margin-top: 15px;
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        .analysis-item {
            background: #2a2a3a;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #444;
        }
        
        .live-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            background: #00d4aa;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.4; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        .timeframe-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 15px 0;
        }
        
        .tf-btn {
            background: #2a2a3a;
            border: 1px solid #444;
            color: #fff;
            padding: 10px 5px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .tf-btn:hover {
            background: #3a3a4a;
        }
        
        .tf-btn.active {
            background: #ff6b35;
            border-color: #ff6b35;
            font-weight: bold;
        }
        
        .section-title {
            color: #ffffff;
            margin: 15px 0 10px 0;
            font-size: 16px;
            border-bottom: 1px solid #333;
            padding-bottom: 8px;
        }
        
        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            margin-bottom: 15px;
            padding: 10px;
            background: #1a1a2e;
            border-radius: 6px;
            border: 1px solid #333;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff6b35;
        }
        
        .status-dot.connected {
            background: #00d4aa;
            animation: pulse 1.5s infinite;
        }
        
        .market-data {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 13px;
            border: 1px solid #333;
        }
        
        .market-data-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 4px 0;
        }
        
        .current-price {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            background: #2a2a3a;
            border-radius: 8px;
            border: 1px solid #444;
        }
        
        .price-up {
            color: #00d4aa;
        }
        
        .price-down {
            color: #ff6b35;
        }

        .deep-analysis {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border: 1px solid #333;
            font-size: 12px;
        }

        .analysis-detail {
            margin-bottom: 8px;
            padding: 5px;
            background: #2a2a3a;
            border-radius: 4px;
        }

        .loading {
            color: #888;
            font-style: italic;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                min-width: 100%;
                max-height: 45vh;
                order: 2;
            }
            
            .main-content {
                order: 1;
                height: 55vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="connection-status">
                <div class="status-dot" id="statusDot"></div>
                <span id="connectionStatus">Disconnected - Click START</span>
            </div>
            
            <div class="section-title">TRADING CONTROL</div>
            <button class="start-stop-btn" id="startStopBtn">START TRADING BOT</button>
            
            <div class="section-title">SELECT SYMBOL</div>
            <select class="symbol-select" id="symbolSelect">
                <option value="BTCUSDT">BTC/USDT</option>
                <option value="ETHUSDT">ETH/USDT</option>
                <option value="BNBUSDT">BNB/USDT</option>
                <option value="ADAUSDT">ADA/USDT</option>
                <option value="DOTUSDT">DOT/USDT</option>
                <option value="LTCUSDT">LTC/USDT</option>
                <option value="XRPUSDT">XRP/USDT</option>
            </select>
            
            <div class="section-title">TIMEFRAME</div>
            <div class="timeframe-selector">
                <button class="tf-btn active" data-tf="1">1m</button>
                <button class="tf-btn" data-tf="5">5m</button>
                <button class="tf-btn" data-tf="15">15m</button>
                <button class="tf-btn" data-tf="60">1h</button>
                <button class="tf-btn" data-tf="240">4h</button>
                <button class="tf-btn" data-tf="1D">1D</button>
            </div>
            
            <div class="current-price">
                <div style="font-size: 12px; color: #888; margin-bottom: 5px;">Current Price</div>
                <div id="currentPrice" class="loading">--</div>
                <div id="priceChange" style="font-size: 14px; margin-top: 5px;" class="loading">0.00%</div>
            </div>
            
            <div class="section-title">NEXT CANDLE PREDICTION</div>
            <div class="prediction-section">
                <div class="prediction-item">
                    <span>Next Candle:</span>
                    <span id="nextCandlePrediction" class="loading">--</span>
                </div>
                <div class="prediction-item">
                    <span>Predicted Direction:</span>
                    <span id="predictedDirection" class="loading">--</span>
                </div>
                <div class="prediction-item">
                    <span>Confidence Level:</span>
                    <span id="predictionConfidence" class="loading">--</span>
                </div>
                <div class="prediction-item">
                    <span>Expected Move:</span>
                    <span id="expectedMove" class="loading">--</span>
                </div>
            </div>
            
            <div class="section-title">TRADING SIGNAL</div>
            <div class="signal-section">
                <div id="currentSignal">
                    <span class="live-indicator"></span>
                    Waiting for signal...
                </div>
                <div id="signalStrength" style="margin-top: 10px; font-size: 13px; color: #888;">
                    Start the bot to begin analysis
                </div>
                <div id="signalReasoning" style="margin-top: 8px; font-size: 11px; color: #aaa;"></div>
            </div>

            <div class="section-title">DEEP ANALYSIS</div>
            <div class="deep-analysis">
                <div class="analysis-detail" id="trendAnalysis" class="loading">Trend: --</div>
                <div class="analysis-detail" id="volumeAnalysis" class="loading">Volume: --</div>
                <div class="analysis-detail" id="momentumAnalysis" class="loading">Momentum: --</div>
                <div class="analysis-detail" id="volatilityAnalysis" class="loading">Volatility: --</div>
                <div class="analysis-detail" id="marketSentiment" class="loading">Market Sentiment: --</div>
            </div>
            
            <div class="section-title">TECHNICAL ANALYSIS</div>
            <div class="analysis-grid">
                <div class="analysis-item">
                    <div>RSI</div>
                    <div class="stat-value loading" id="rsiValue">--</div>
                </div>
                <div class="analysis-item">
                    <div>MACD</div>
                    <div class="stat-value loading" id="macdValue">--</div>
                </div>
                <div class="analysis-item">
                    <div>Stoch RSI</div>
                    <div class="stat-value loading" id="stochRsiValue">--</div>
                </div>
                <div class="analysis-item">
                    <div>BB Position</div>
                    <div class="stat-value loading" id="bbPosition">--</div>
                </div>
            </div>
            
            <div class="section-title">SUPPORT & RESISTANCE</div>
            <div class="analysis-grid">
                <div class="analysis-item">
                    <div>Support 1</div>
                    <div class="stat-value loading" id="support1">--</div>
                </div>
                <div class="analysis-item">
                    <div>Resistance 1</div>
                    <div class="stat-value loading" id="resistance1">--</div>
                </div>
                <div class="analysis-item">
                    <div>Support 2</div>
                    <div class="stat-value loading" id="support2">--</div>
                </div>
                <div class="analysis-item">
                    <div>Resistance 2</div>
                    <div class="stat-value loading" id="resistance2">--</div>
                </div>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <div class="control-panel">
                <div class="symbol-selector">
                    <span style="font-weight: bold; color: #00d4aa;">Advanced Market Analysis</span>
                </div>
                <div id="currentTime" style="color: #888; font-size: 14px; font-weight: bold;"></div>
            </div>
            <div class="chart-container">
                <div id="tradingview_chart"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let tradingViewWidget = null;
        let binanceWS = null;
        let isBotRunning = false;
        let currentSymbol = 'BTCUSDT';
        let currentTimeframe = '1';
        let priceData = [];
        let volumeData = [];
        let historicalData = [];
        let dataUpdateInterval = null;

        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Initializing Advanced Trading Bot...');
            initializeTradingView();
            initializeEventListeners();
            updateCurrentTime();
            setInterval(updateCurrentTime, 1000);
            
            // Load initial historical data
            loadHistoricalData();
        });

        // Initialize TradingView widget with CLEAN CHART
        function initializeTradingView() {
            console.log('Initializing TradingView for:', currentSymbol);
            
            if (tradingViewWidget !== null) {
                tradingViewWidget.remove();
                tradingViewWidget = null;
            }

            setTimeout(() => {
                try {
                    tradingViewWidget = new TradingView.widget({
                        container_id: "tradingview_chart",
                        symbol: `BINANCE:${currentSymbol}`,
                        interval: currentTimeframe,
                        timezone: "Asia/Dhaka",
                        theme: "dark",
                        style: "1",
                        locale: "en",
                        toolbar_bg: "#1a1a2e",
                        enable_publishing: false,
                        hide_side_toolbar: false,
                        allow_symbol_change: false,
                        save_image: false,
                        
                        // NO STUDIES/INDICATORS - CLEAN CHART
                        studies: [],
                        
                        disabled_features: [
                            "use_localstorage_for_settings",
                            "volume_force_overlay",
                            "left_toolbar"
                        ],
                        enabled_features: [
                            "move_logo_to_main_pane"
                        ],
                        width: "100%",
                        height: "100%",
                        autosize: true,
                        overrides: {
                            "paneProperties.background": "#0c0c0c",
                            "paneProperties.vertGridProperties.color": "#1a1a2e",
                            "paneProperties.horzGridProperties.color": "#1a1a2e",
                            "symbolWatermarkProperties.color": "rgba(0, 0, 0, 0)",
                            "mainSeriesProperties.candleStyle.upColor": "#00d4aa",
                            "mainSeriesProperties.candleStyle.downColor": "#ff6b35",
                            "mainSeriesProperties.candleStyle.borderUpColor": "#00d4aa",
                            "mainSeriesProperties.candleStyle.borderDownColor": "#ff6b35",
                            "mainSeriesProperties.candleStyle.wickUpColor": "#00d4aa",
                            "mainSeriesProperties.candleStyle.wickDownColor": "#ff6b35",
                        }
                    });

                    tradingViewWidget.onChartReady(function() {
                        console.log('✅ TradingView CLEAN chart ready for:', currentSymbol);
                        if (isBotRunning) {
                            startRealTimeData();
                        }
                    });
                } catch (error) {
                    console.error('❌ TradingView initialization failed:', error);
                }
            }, 500);
        }

        // Initialize event listeners
        function initializeEventListeners() {
            console.log('🔧 Initializing event listeners...');
            
            // Start/Stop button
            const startStopBtn = document.getElementById('startStopBtn');
            startStopBtn.addEventListener('click', function(e) {
                console.log('🔄 Start/Stop button clicked');
                e.stopPropagation();
                toggleBot();
            });
            
            // Symbol selection
            const symbolSelect = document.getElementById('symbolSelect');
            symbolSelect.addEventListener('change', function(e) {
                console.log('🎯 Symbol changed to:', e.target.value);
                currentSymbol = e.target.value;
                if (isBotRunning) {
                    stopBot();
                }
                // Reset data
                priceData = [];
                volumeData = [];
                historicalData = [];
                
                initializeTradingView();
                loadHistoricalData();
                
                if (isBotRunning) {
                    setTimeout(() => startBot(), 2000);
                }
            });
            
            // Timeframe buttons
            document.querySelectorAll('.tf-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    console.log('⏰ Timeframe changed to:', e.target.dataset.tf);
                    e.stopPropagation();
                    document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentTimeframe = e.target.dataset.tf;
                    if (isBotRunning) {
                        stopBot();
                    }
                    
                    initializeTradingView();
                    loadHistoricalData();
                    
                    if (isBotRunning) {
                        setTimeout(() => startBot(), 2000);
                    }
                });
            });
            
            console.log('✅ Event listeners initialized');
        }

        // Toggle bot state
        function toggleBot() {
            console.log('🔄 Toggle bot called, current state:', isBotRunning);
            if (isBotRunning) {
                stopBot();
            } else {
                startBot();
            }
        }

        // Start trading bot
        function startBot() {
            console.log('🚀 Starting bot for:', currentSymbol);
            isBotRunning = true;
            
            updateButtonStates();
            updateConnectionStatus('Connecting to Binance...', false);
            
            document.getElementById('currentSignal').innerHTML = 
                '<span class="live-indicator"></span> Starting deep analysis...';
            document.getElementById('signalStrength').textContent = 'Initializing data streams...';
            document.getElementById('signalReasoning').textContent = 'Loading market data...';
            
            startRealTimeData();
            
            console.log('✅ Trading Bot Started');
        }

        // Stop trading bot
        function stopBot() {
            console.log('🛑 Stopping bot...');
            isBotRunning = false;
            
            if (binanceWS) {
                binanceWS.close();
                binanceWS = null;
            }
            
            if (dataUpdateInterval) {
                clearInterval(dataUpdateInterval);
                dataUpdateInterval = null;
            }
            
            updateButtonStates();
            updateConnectionStatus('Disconnected', false);
            
            document.getElementById('currentSignal').innerHTML = 
                '<span class="live-indicator" style="background: #ff6b35;"></span> Bot Stopped';
            document.getElementById('signalStrength').textContent = 'Click START to begin trading';
            document.getElementById('signalReasoning').textContent = '';
            
            console.log('✅ Trading Bot Stopped');
        }

        // Update button states
        function updateButtonStates() {
            const buttonText = isBotRunning ? 'STOP TRADING BOT' : 'START TRADING BOT';
            const button = document.getElementById('startStopBtn');
            
            button.textContent = buttonText;
            if (isBotRunning) {
                button.classList.add('stop');
            } else {
                button.classList.remove('stop');
            }
        }

        // Start real-time data stream
        function startRealTimeData() {
            console.log('📡 Starting real-time data for:', currentSymbol);
            startBinanceWebSocket();
            startMarketDataPolling();
        }

        // Start Binance WebSocket - FIXED VERSION
        function startBinanceWebSocket() {
            const symbol = currentSymbol.toLowerCase();
            const timeframe = getTimeframeString();
            
            console.log('🔌 WebSocket connecting to:', symbol, 'timeframe:', timeframe);
            
            // Close existing connection
            if (binanceWS) {
                binanceWS.close();
                binanceWS = null;
            }

            try {
                const wsUrl = `wss://stream.binance.com:9443/ws/${symbol}@kline_${timeframe}`;
                console.log('🌐 WebSocket URL:', wsUrl);
                
                binanceWS = new WebSocket(wsUrl);
                
                binanceWS.onopen = function(event) {
                    console.log('✅ WebSocket connected successfully');
                    updateConnectionStatus('Connected - Live Data', true);
                    
                    document.getElementById('currentSignal').innerHTML = 
                        '<span class="live-indicator"></span> Deep Analysis Running...';
                    document.getElementById('signalStrength').textContent = 'Receiving real-time data';
                    document.getElementById('signalReasoning').textContent = 'Analyzing market conditions...';
                    
                    // Generate initial analysis with historical data
                    if (historicalData.length > 0) {
                        const latestData = historicalData[historicalData.length - 1];
                        simulateRealTimeData(latestData);
                    }
                };
                
                binanceWS.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('📨 WebSocket message received:', data);
                        
                        if (data.k) {
                            processKlineData(data);
                        }
                    } catch (error) {
                        console.error('❌ Error parsing WebSocket message:', error);
                    }
                };
                
                binanceWS.onerror = function(error) {
                    console.error('❌ WebSocket error:', error);
                    updateConnectionStatus('Connection Error', false);
                };
                
                binanceWS.onclose = function(event) {
                    console.log('🔌 WebSocket closed:', event.code, event.reason);
                    if (isBotRunning) {
                        console.log('🔄 Reconnecting WebSocket in 3 seconds...');
                        setTimeout(startBinanceWebSocket, 3000);
                    }
                };
                
            } catch (error) {
                console.error('❌ WebSocket creation failed:', error);
                updateConnectionStatus('WebSocket Failed - Using Simulated Data', false);
                
                // Fallback to simulated data
                startSimulatedData();
            }
        }

        // Simulated data fallback
        function startSimulatedData() {
            console.log('🔄 Starting simulated data fallback');
            
            if (dataUpdateInterval) {
                clearInterval(dataUpdateInterval);
            }
            
            dataUpdateInterval = setInterval(() => {
                if (!isBotRunning) return;
                
                if (historicalData.length > 0) {
                    const latestData = historicalData[historicalData.length - 1];
                    simulateRealTimeData(latestData);
                }
            }, 2000); // Update every 2 seconds
        }

        // Simulate real-time data updates
        function simulateRealTimeData(baseData) {
            const volatility = 0.002; // 0.2% volatility
            const randomChange = (Math.random() - 0.5) * 2 * volatility;
            const newPrice = baseData.close * (1 + randomChange);
            const newVolume = baseData.volume * (0.8 + Math.random() * 0.4);
            
            const simulatedData = {
                time: Date.now() / 1000,
                open: baseData.open,
                high: Math.max(baseData.high, newPrice),
                low: Math.min(baseData.low, newPrice),
                close: newPrice,
                volume: newVolume,
                isFinal: true
            };
            
            processKlineData({ k: simulatedData });
        }

        // Load historical data for analysis
        async function loadHistoricalData() {
            console.log('📊 Loading historical data for:', currentSymbol);
            
            try {
                const timeframe = getTimeframeString();
                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${currentSymbol}&interval=${timeframe}&limit=100`);
                
                if (response.ok) {
                    const data = await response.json();
                    historicalData = data.map(kline => ({
                        open: parseFloat(kline[1]),
                        high: parseFloat(kline[2]),
                        low: parseFloat(kline[3]),
                        close: parseFloat(kline[4]),
                        volume: parseFloat(kline[5]),
                        time: parseInt(kline[0])
                    }));
                    
                    // Initialize priceData with historical closes
                    priceData = historicalData.map(item => item.close);
                    volumeData = historicalData.map(item => item.volume);
                    
                    console.log('✅ Historical data loaded:', historicalData.length, 'candles');
                    
                    // Perform initial analysis
                    if (historicalData.length > 0) {
                        const latestData = historicalData[historicalData.length - 1];
                        performDeepAnalysis(latestData);
                        predictNextCandle(latestData);
                        generateTradingSignal(latestData);
                    }
                } else {
                    console.error('❌ Historical data fetch failed:', response.status);
                }
            } catch (error) {
                console.error('❌ Historical data load failed:', error);
            }
        }

        // Process kline/candlestick data
        function processKlineData(data) {
            if (!isBotRunning) return;
            
            let candleData;
            
            if (data.k && typeof data.k === 'object') {
                // Real WebSocket data
                const kline = data.k;
                candleData = {
                    time: kline.t / 1000,
                    open: parseFloat(kline.o),
                    high: parseFloat(kline.h),
                    low: parseFloat(kline.l),
                    close: parseFloat(kline.c),
                    volume: parseFloat(kline.v),
                    isFinal: kline.x
                };
            } else if (data.k && typeof data.k.close === 'number') {
                // Simulated data
                candleData = data.k;
            } else {
                console.error('❌ Invalid kline data structure:', data);
                return;
            }
            
            console.log('🕯️ Processing candle data:', candleData);
            
            // Update data arrays
            if (candleData.isFinal || priceData.length === 0) {
                priceData.push(candleData.close);
                volumeData.push(candleData.volume);
                
                if (priceData.length > 100) {
                    priceData.shift();
                    volumeData.shift();
                }
            }
            
            updatePriceDisplay(candleData);
            performDeepAnalysis(candleData);
            predictNextCandle(candleData);
            generateTradingSignal(candleData);
            
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

        // Update price display
        function updatePriceDisplay(data) {
            const currentPrice = data.close;
            const openPrice = data.open;
            const priceChange = ((currentPrice - openPrice) / openPrice * 100);
            
            document.getElementById('currentPrice').textContent = currentPrice.toFixed(4);
            document.getElementById('currentPrice').className = '';
            
            document.getElementById('priceChange').textContent = priceChange.toFixed(2) + '%';
            
            if (priceChange >= 0) {
                document.getElementById('currentPrice').classList.add('price-up');
                document.getElementById('priceChange').className = 'positive';
            } else {
                document.getElementById('currentPrice').classList.add('price-down');
                document.getElementById('priceChange').className = 'negative';
            }
            
            document.getElementById('dailyHigh').textContent = data.high.toFixed(4);
            document.getElementById('dailyLow').textContent = data.low.toFixed(4);
            document.getElementById('volume24h').textContent = formatVolume(data.volume);
        }

        // Start market data polling
        function startMarketDataPolling() {
            console.log('🔄 Starting market data polling');
            fetchAdditionalMarketData();
            
            if (dataUpdateInterval) {
                clearInterval(dataUpdateInterval);
            }
            
            dataUpdateInterval = setInterval(() => {
                if (!isBotRunning) return;
                fetchAdditionalMarketData();
            }, 15000); // Poll every 15 seconds
        }

        // Fetch additional market data
        async function fetchAdditionalMarketData() {
            if (!isBotRunning) return;
            
            try {
                const response = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${currentSymbol}`);
                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('volume24h').textContent = formatVolume(parseFloat(data.volume));
                }
            } catch (error) {
                console.log('⚠️ Additional data fetch failed');
            }
        }

        // Perform deep market analysis
        function performDeepAnalysis(data) {
            if (priceData.length < 5) {
                console.log('⚠️ Not enough data for analysis');
                return;
            }
            
            console.log('🔍 Performing deep analysis with', priceData.length, 'data points');
            
            // Calculate multiple technical indicators
            const rsi = calculateRSI(priceData, 14);
            const macd = calculateMACD(priceData);
            const stochRsi = calculateStochRSI(priceData);
            const bbPosition = calculateBBPosition(priceData, data.close);
            const trend = analyzeAdvancedTrend(priceData);
            const momentum = calculateAdvancedMomentum(priceData);
            const volatility = calculateVolatility(priceData);
            const volumeTrend = analyzeVolumeTrend(volumeData);
            
            console.log('📊 Analysis results:', { rsi, macd, trend, momentum, volatility });
            
            // Update technical analysis display
            updateIndicatorUI('rsiValue', rsi, 30, 70);
            updateIndicatorUI('macdValue', macd, -0.001, 0.001);
            updateIndicatorUI('stochRsiValue', stochRsi, 20, 80);
            
            if (bbPosition) {
                document.getElementById('bbPosition').textContent = bbPosition;
                document.getElementById('bbPosition').className = 
                    bbPosition === 'Upper' ? 'stat-value negative' : 
                    bbPosition === 'Lower' ? 'stat-value positive' : 'stat-value neutral';
            }
            
            // Update deep analysis
            if (trend) {
                document.getElementById('trendAnalysis').textContent = 
                    `Trend: ${trend.direction} (Strength: ${(trend.strength * 100).toFixed(1)}%)`;
                document.getElementById('trendAnalysis').className = '';
            }
            
            if (volumeTrend) {
                document.getElementById('volumeAnalysis').textContent = `Volume: ${volumeTrend}`;
                document.getElementById('volumeAnalysis').className = '';
            }
            
            if (momentum) {
                document.getElementById('momentumAnalysis').textContent = 
                    `Momentum: ${momentum.direction} (${(momentum.strength * 100).toFixed(1)}%)`;
                document.getElementById('momentumAnalysis').className = '';
            }
            
            if (volatility) {
                document.getElementById('volatilityAnalysis').textContent = 
                    `Volatility: ${volatility.level} (${volatility.percentage.toFixed(2)}%)`;
                document.getElementById('volatilityAnalysis').className = '';
            }
            
            // Calculate market sentiment
            const sentiment = calculateMarketSentiment(rsi, macd, trend, momentum);
            if (sentiment) {
                document.getElementById('marketSentiment').textContent = `Market Sentiment: ${sentiment}`;
                document.getElementById('marketSentiment').className = 
                    sentiment === 'Bullish' ? 'positive' : 
                    sentiment === 'Bearish' ? 'negative' : 'hold';
            }
            
            // Update support and resistance
            updateSupportResistance(priceData);
        }

        // Predict next candle
        function predictNextCandle(currentData) {
            if (priceData.length < 10) return;
            
            const lastPrice = currentData.close;
            const trend = analyzeAdvancedTrend(priceData);
            const momentum = calculateAdvancedMomentum(priceData);
            const rsi = calculateRSI(priceData, 14);
            const volatility = calculateVolatility(priceData);
            
            if (!trend || !momentum || !rsi || !volatility) return;
            
            // Advanced prediction algorithm
            let prediction = 'NEUTRAL';
            let confidence = 50;
            let expectedMove = volatility.percentage;
            
            // Trend-based prediction
            if (trend.strength > 0.7) {
                prediction = trend.direction === 'BULLISH' ? 'BULLISH' : 'BEARISH';
                confidence += 20;
            }
            
            // Momentum-based prediction
            if (momentum.strength > 0.6) {
                if (momentum.direction === 'UP') {
                    prediction = 'BULLISH';
                    confidence += 15;
                } else {
                    prediction = 'BEARISH';
                    confidence += 15;
                }
            }
            
            // RSI-based prediction
            if (rsi < 25) {
                prediction = 'BULLISH';
                confidence += 10;
            } else if (rsi > 75) {
                prediction = 'BEARISH';
                confidence += 10;
            }
            
            console.log('🔮 Next candle prediction:', { prediction, confidence, expectedMove });
            
            // Update prediction display
            document.getElementById('nextCandlePrediction').textContent = prediction;
            document.getElementById('nextCandlePrediction').className = 
                prediction === 'BULLISH' ? 'positive' : 
                prediction === 'BEARISH' ? 'negative' : 'hold';
            
            document.getElementById('predictedDirection').textContent = 
                prediction === 'BULLISH' ? 'UP ↗' : 
                prediction === 'BEARISH' ? 'DOWN ↘' : 'SIDEWAYS →';
            
            document.getElementById('predictionConfidence').textContent = Math.min(confidence, 95) + '%';
            document.getElementById('predictionConfidence').className = 
                confidence > 70 ? 'positive' : 
                confidence > 50 ? 'hold' : 'negative';
            
            document.getElementById('expectedMove').textContent = expectedMove.toFixed(2) + '%';
            document.getElementById('expectedMove').className = '';
        }

        // Generate advanced trading signal
        function generateTradingSignal(data) {
            if (priceData.length < 10) return;
            
            const rsi = calculateRSI(priceData, 14);
            const macd = calculateMACD(priceData);
            const trend = analyzeAdvancedTrend(priceData);
            const momentum = calculateAdvancedMomentum(priceData);
            const bbPosition = calculateBBPosition(priceData, data.close);
            
            if (!rsi || !macd || !trend || !momentum) return;
            
            const sentiment = calculateMarketSentiment(rsi, macd, trend, momentum);
            
            let signal = 'HOLD';
            let confidence = 0;
            let reasoning = [];
            
            // Deep analysis conditions
            const conditions = {
                oversold: rsi < 25,
                overbought: rsi > 75,
                strongUptrend: trend.strength > 0.7 && trend.direction === 'BULLISH',
                strongDowntrend: trend.strength > 0.7 && trend.direction === 'BEARISH',
                bullishMomentum: momentum.strength > 0.6 && momentum.direction === 'UP',
                bearishMomentum: momentum.strength > 0.6 && momentum.direction === 'DOWN',
                lowerBB: bbPosition === 'Lower',
                upperBB: bbPosition === 'Upper',
                bullishSentiment: sentiment === 'Bullish',
                bearishSentiment: sentiment === 'Bearish'
            };
            
            // BUY Signal Conditions
            const buyConditions = [
                conditions.oversold,
                conditions.strongUptrend,
                conditions.bullishMomentum,
                conditions.lowerBB,
                conditions.bullishSentiment
            ];
            
            // SELL Signal Conditions
            const sellConditions = [
                conditions.overbought,
                conditions.strongDowntrend,
                conditions.bearishMomentum,
                conditions.upperBB,
                conditions.bearishSentiment
            ];
            
            const buyScore = buyConditions.filter(Boolean).length;
            const sellScore = sellConditions.filter(Boolean).length;
            
            console.log('🎯 Signal conditions:', { buyScore, sellScore, conditions });
            
            if (buyScore >= 3) {
                signal = 'BUY';
                confidence = 40 + (buyScore * 12);
                if (conditions.oversold) reasoning.push('RSI Oversold');
                if (conditions.strongUptrend) reasoning.push('Strong Uptrend');
                if (conditions.bullishMomentum) reasoning.push('Bullish Momentum');
                if (conditions.lowerBB) reasoning.push('Lower Bollinger Band');
                if (conditions.bullishSentiment) reasoning.push('Bullish Sentiment');
            } else if (sellScore >= 3) {
                signal = 'SELL';
                confidence = 40 + (sellScore * 12);
                if (conditions.overbought) reasoning.push('RSI Overbought');
                if (conditions.strongDowntrend) reasoning.push('Strong Downtrend');
                if (conditions.bearishMomentum) reasoning.push('Bearish Momentum');
                if (conditions.upperBB) reasoning.push('Upper Bollinger Band');
                if (conditions.bearishSentiment) reasoning.push('Bearish Sentiment');
            } else {
                signal = 'HOLD';
                confidence = 60;
                reasoning.push('Market Conditions Neutral');
                reasoning.push('Waiting for Stronger Signals');
            }
            
            console.log('💡 Generated signal:', { signal, confidence, reasoning });
            
            updateSignalDisplay(signal, confidence, reasoning);
        }

        // Update signal display
        function updateSignalDisplay(signal, confidence, reasoning) {
            const signalElement = document.getElementById('currentSignal');
            const strengthElement = document.getElementById('signalStrength');
            const reasoningElement = document.getElementById('signalReasoning');
            
            if (signal === 'BUY') {
                signalElement.className = 'signal-buy';
                signalElement.innerHTML = `<span class="live-indicator"></span> 🎯 BUY SIGNAL`;
            } else if (signal === 'SELL') {
                signalElement.className = 'signal-sell';
                signalElement.innerHTML = `<span class="live-indicator"></span> 💥 SELL SIGNAL`;
            } else {
                signalElement.className = 'signal-hold';
                signalElement.innerHTML = `<span class="live-indicator"></span> ⏸️ HOLD SIGNAL`;
            }
            
            strengthElement.textContent = `Confidence: ${Math.min(confidence, 95)}%`;
            strengthElement.style.color = '#ffffff';
            
            reasoningElement.textContent = `Reasons: ${reasoning.slice(0, 2).join(', ')}${reasoning.length > 2 ? '...' : ''}`;
            reasoningElement.style.color = '#aaa';
        }

        // [Rest of the technical analysis functions remain the same as previous version]
        // Advanced technical analysis functions
        function calculateAdvancedTrend(prices) {
            if (prices.length < 20) return null;
            
            const shortMA = calculateEMA(prices, 5);
            const mediumMA = calculateEMA(prices, 10);
            const longMA = calculateEMA(prices, 20);
            
            if (!shortMA || !mediumMA || !longMA) return null;
            
            let direction = 'NEUTRAL';
            let strength = 0;
            
            if (shortMA > mediumMA && mediumMA > longMA) {
                direction = 'BULLISH';
                strength = ((shortMA - longMA) / longMA);
            } else if (shortMA < mediumMA && mediumMA < longMA) {
                direction = 'BEARISH';
                strength = ((longMA - shortMA) / shortMA);
            }
            
            return { direction, strength: Math.min(Math.abs(strength), 1) };
        }

        function calculateAdvancedMomentum(prices) {
            if (prices.length < 10) return null;
            
            const current = prices[prices.length - 1];
            const past = prices[prices.length - 5];
            const momentum = ((current - past) / past);
            
            let direction = momentum > 0 ? 'UP' : momentum < 0 ? 'DOWN' : 'NEUTRAL';
            let strength = Math.min(Math.abs(momentum) / 0.02, 1); // Normalize to 0-1
            
            return { direction, strength };
        }

        function calculateVolatility(prices) {
            if (prices.length < 20) return null;
            
            const returns = [];
            for (let i = 1; i < prices.length; i++) {
                returns.push(Math.abs((prices[i] - prices[i-1]) / prices[i-1]));
            }
            
            const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
            const volatility = avgReturn * 100;
            
            let level = 'LOW';
            if (volatility > 2) level = 'HIGH';
            else if (volatility > 1) level = 'MEDIUM';
            
            return { level, percentage: volatility };
        }

        function analyzeVolumeTrend(volumes) {
            if (volumes.length < 10) return null;
            
            const currentVolume = volumes[volumes.length - 1];
            const avgVolume = volumes.slice(-10).reduce((a, b) => a + b, 0) / 10;
            const ratio = currentVolume / avgVolume;
            
            if (ratio > 1.5) return 'HIGH';
            if (ratio > 1.2) return 'ABOVE_AVERAGE';
            if (ratio < 0.8) return 'LOW';
            return 'AVERAGE';
        }

        function calculateBBPosition(prices, currentPrice) {
            if (prices.length < 20) return null;
            
            const period = 20;
            const slice = prices.slice(-period);
            const mean = slice.reduce((a, b) => a + b, 0) / slice.length;
            const variance = slice.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / slice.length;
            const stdDev = Math.sqrt(variance);
            
            const upperBand = mean + (2 * stdDev);
            const lowerBand = mean - (2 * stdDev);
            
            if (currentPrice >= upperBand * 0.98) return 'Upper';
            if (currentPrice <= lowerBand * 1.02) return 'Lower';
            return 'Middle';
        }

        function calculateMarketSentiment(rsi, macd, trend, momentum) {
            if (!rsi || !macd || !trend || !momentum) return null;
            
            let score = 0;
            
            if (rsi < 40) score += 1;
            if (rsi > 60) score -= 1;
            if (macd > 0) score += 1;
            if (macd < 0) score -= 1;
            if (trend.direction === 'BULLISH') score += 1;
            if (trend.direction === 'BEARISH') score -= 1;
            if (momentum.direction === 'UP') score += 1;
            if (momentum.direction === 'DOWN') score -= 1;
            
            if (score >= 2) return 'Bullish';
            if (score <= -2) return 'Bearish';
            return 'Neutral';
        }

        // Basic technical indicator functions
        function calculateRSI(prices, period) {
            if (prices.length < period + 1) return null;
            let gains = 0, losses = 0;
            for (let i = 1; i <= period; i++) {
                const diff = prices[prices.length - i] - prices[prices.length - i - 1];
                if (diff > 0) gains += diff; else losses -= diff;
            }
            const avgGain = gains / period, avgLoss = losses / period;
            if (avgLoss === 0) return 100;
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        function calculateMACD(prices) {
            if (prices.length < 26) return null;
            const ema12 = calculateEMA(prices, 12), ema26 = calculateEMA(prices, 26);
            return ema12 - ema26;
        }

        function calculateStochRSI(prices, period = 14) {
            const rsi = calculateRSI(prices, period);
            return rsi ? (rsi - 30) / (70 - 30) * 100 : null;
        }

        function calculateEMA(prices, period) {
            if (prices.length < period) return null;
            const k = 2 / (period + 1);
            let ema = prices[0];
            for (let i = 1; i < prices.length; i++) ema = prices[i] * k + ema * (1 - k);
            return ema;
        }

        function updateSupportResistance(prices) {
            if (prices.length < 20) return;
            
            const recentPrices = prices.slice(-20);
            const support1 = Math.min(...recentPrices.slice(-10));
            const resistance1 = Math.max(...recentPrices.slice(-10));
            const support2 = support1 * 0.995;
            const resistance2 = resistance1 * 1.005;
            
            document.getElementById('support1').textContent = support1.toFixed(4);
            document.getElementById('resistance1').textContent = resistance1.toFixed(4);
            document.getElementById('support2').textContent = support2.toFixed(4);
            document.getElementById('resistance2').textContent = resistance2.toFixed(4);
            
            // Remove loading class
            ['support1', 'resistance1', 'support2', 'resistance2'].forEach(id => {
                document.getElementById(id).classList.remove('loading');
            });
        }

        // Utility functions
        function updateConnectionStatus(status, isConnected) {
            document.getElementById('connectionStatus').textContent = status;
            document.getElementById('statusDot').className = isConnected ? 'status-dot connected' : 'status-dot';
        }

        function updateIndicatorUI(elementId, value, lowerThreshold, upperThreshold) {
            const element = document.getElementById(elementId);
            if (value !== null && !isNaN(value)) {
                element.textContent = typeof value === 'number' ? value.toFixed(2) : value;
                element.classList.remove('loading');
                
                if (typeof value === 'number') {
                    if (value < lowerThreshold) element.className = 'stat-value positive';
                    else if (value > upperThreshold) element.className = 'stat-value negative';
                    else element.className = 'stat-value neutral';
                }
            }
        }

        function formatVolume(volume) {
            if (volume >= 1000000) return (volume / 1000000).toFixed(2) + 'M';
            if (volume >= 1000) return (volume / 1000).toFixed(2) + 'K';
            return volume.toFixed(2);
        }

        function getTimeframeString() {
            const tfMap = {'1': '1m', '5': '5m', '15': '15m', '60': '1h', '240': '4h', '1D': '1d'};
            return tfMap[currentTimeframe] || '1m';
        }

        function updateCurrentTime() {
            document.getElementById('currentTime').textContent = new Date().toLocaleTimeString();
        }
    </script>
</body>
</html>
